use std::{str::FromStr, string::ParseError};

#[derive(Debug)]
struct Claim {
    id: i32,
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

impl Claim {
    fn overlap(self, claim: Claim) -> i32 {
        0
    }
}

impl FromStr for Claim {
    type Err = ParseError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        // #123 @ 45;56: 213x18

        println!(
            "{}",
            s.split_once(" @ ").unwrap().1.split_once(": ").unwrap().0
        );

        let (id, rectangle) = s.split_once(" @ ").unwrap();
        let (coordinates, size) = rectangle.split_once(": ").unwrap();
        let (x, y) = coordinates.split_once(";").unwrap();
        let (width, height) = size.split_once("x").unwrap();

        Ok(Self {
            id: id[1..].parse().unwrap(),
            x: x.parse().unwrap(),
            y: y.parse().unwrap(),
            width: width.parse().unwrap(),
            height: height.parse().unwrap(),
        })
    }
}

fn part_one() -> i32 {
    let claims: Vec<Claim> = include_str!("input")
        .trim()
        .lines()
        .map(str::parse)
        .map(Result::unwrap)
        .collect();

    println!("{:?}", claims);

    10
}

fn main() {
    println!("{}", part_one());
}
